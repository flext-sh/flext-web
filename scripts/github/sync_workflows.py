#!/usr/bin/env python3
# Owner-Skill: .claude/skills/rules-github/SKILL.md
from __future__ import annotations

import argparse
import json
import sys
from dataclasses import dataclass
from pathlib import Path

REPO_ROOT = Path(__file__).resolve().parents[2]
if str(REPO_ROOT) not in sys.path:
    sys.path.insert(0, str(REPO_ROOT))

from libs.selection import resolve_projects

GENERATED_HEADER = "# Generated by scripts/github/sync_workflows.py - DO NOT EDIT\n"
MANAGED_FILES = {"ci.yml"}


@dataclass(frozen=True)
class Operation:
    project: str
    path: str
    action: str
    reason: str


def _discover_projects(workspace_root: Path) -> list[tuple[str, Path]]:
    return [
        (project.name, project.path)
        for project in resolve_projects(workspace_root, names=[])
    ]


def _render_template(template_path: Path) -> str:
    body = template_path.read_text(encoding="utf-8")
    if body.startswith(GENERATED_HEADER):
        return body
    return GENERATED_HEADER + body


def _resolve_source_workflow(
    workspace_root: Path, source_workflow: Path | None
) -> Path:
    if source_workflow is not None:
        candidate = (
            source_workflow
            if source_workflow.is_absolute()
            else (workspace_root / source_workflow)
        ).resolve()
        if candidate.exists():
            return candidate
        raise RuntimeError(f"missing source workflow: {candidate}")

    default_source = (workspace_root / ".github" / "workflows" / "ci.yml").resolve()
    if default_source.exists():
        return default_source
    raise RuntimeError(f"missing source workflow: {default_source}")


def _sync_project(
    *,
    project_name: str,
    project_root: Path,
    rendered_template: str,
    apply: bool,
    prune: bool,
) -> list[Operation]:
    operations: list[Operation] = []
    workflows_dir = project_root / ".github" / "workflows"
    destination = workflows_dir / "ci.yml"

    if destination.exists():
        current = destination.read_text(encoding="utf-8")
        if current != rendered_template:
            if apply:
                _ = destination.write_text(rendered_template, encoding="utf-8")
            operations.append(
                Operation(
                    project=project_name,
                    path=str(destination.relative_to(project_root)),
                    action="update",
                    reason="force overwrite ci.yml",
                )
            )
        else:
            operations.append(
                Operation(
                    project=project_name,
                    path=str(destination.relative_to(project_root)),
                    action="noop",
                    reason="already synced",
                )
            )
    else:
        if apply:
            workflows_dir.mkdir(parents=True, exist_ok=True)
            _ = destination.write_text(rendered_template, encoding="utf-8")
        operations.append(
            Operation(
                project=project_name,
                path=str(destination.relative_to(project_root)),
                action="create",
                reason="missing ci.yml",
            )
        )

    if prune and workflows_dir.exists():
        candidates = sorted(workflows_dir.glob("*.yml")) + sorted(
            workflows_dir.glob("*.yaml")
        )
        for path in candidates:
            if path.name in MANAGED_FILES:
                continue
            if apply:
                path.unlink()
            operations.append(
                Operation(
                    project=project_name,
                    path=str(path.relative_to(project_root)),
                    action="prune",
                    reason="remove non-canonical workflow",
                )
            )

    return operations


def _write_report(report_path: Path, mode: str, operations: list[Operation]) -> None:
    report_path.parent.mkdir(parents=True, exist_ok=True)
    by_action: dict[str, int] = {}
    for operation in operations:
        by_action[operation.action] = by_action.get(operation.action, 0) + 1
    payload = {
        "mode": mode,
        "summary": by_action,
        "operations": [
            {
                "project": operation.project,
                "path": operation.path,
                "action": operation.action,
                "reason": operation.reason,
            }
            for operation in operations
        ],
    }
    _ = report_path.write_text(
        json.dumps(payload, indent=2, sort_keys=True) + "\n", encoding="utf-8"
    )


def _parse_args(argv: list[str]) -> argparse.Namespace:
    parser = argparse.ArgumentParser()
    _ = parser.add_argument("--workspace-root", default=".", type=Path)
    _ = parser.add_argument("--source-workflow", type=Path)
    _ = parser.add_argument(
        "--report",
        default=".reports/workflows/sync.json",
        type=Path,
    )
    _ = parser.add_argument("--apply", action="store_true")
    _ = parser.add_argument("--prune", action="store_true")
    return parser.parse_args(argv)


def main(argv: list[str] | None = None) -> int:
    args = _parse_args(sys.argv[1:] if argv is None else argv)
    workspace_root = args.workspace_root.resolve()
    report = (
        args.report if args.report.is_absolute() else (workspace_root / args.report)
    )

    source_workflow = _resolve_source_workflow(workspace_root, args.source_workflow)

    projects = _discover_projects(workspace_root)
    rendered_template = _render_template(source_workflow)
    operations: list[Operation] = []

    for project_name, project_root in projects:
        operations.extend(
            _sync_project(
                project_name=project_name,
                project_root=project_root,
                rendered_template=rendered_template,
                apply=args.apply,
                prune=args.prune,
            )
        )

    mode = "apply" if args.apply else "dry-run"
    _write_report(report.resolve(), mode, operations)
    print(f"Wrote: {report}")
    for operation in operations:
        print(
            f"[{operation.project}] {operation.action}: {operation.path} ({operation.reason})"
        )
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
